{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prefecto Prefecto is a collection of tools to extend and augment Prefect capabilities. Getting Started Install Prefecto with pip install prefecto Prefecto is only tested with Python 3.10 and higher. It may work with older versions, but it is not guaranteed. Break Task.map into smaller concurrent batches . from prefect import flow, task from prefecto.concurrency import BatchTask, CountSwitch @task def my_task(x): if x % 100 == 0: raise ValueError(f\"{x} is divisible by 100.\") return x @flow def my_flow(): results = BatchTask( my_task, size=100, kill_switch=CountSwitch(15), ).map(range(1000)) Simply and efficiently define and load blocks for dev/test/prod environments. # .env BLOCKS_PASSWORD_BLOCK=secret-password-test from prefect.blocks.system import Secret from prefecto.blocks import lazy_load from pydantic_settings import BaseSettings, SettingsConfigDict class Blocks(BaseSettings): \"\"\"Class for lazy loading Prefect Blocks.\"\"\" model_config = SettingsConfigDict(env_prefix=\"BLOCKS_\") # Define the block name variables password_block: str = \"secret-password\" @property @lazy_load(\"password_block\") def password(self) -> Secret: \"\"\"The password block.\"\"\" blocks = Blocks() password = blocks.password print(password.password_block) # secret-password-test print(password.get()) # my-secret-test-password$123","title":"Home"},{"location":"#prefecto","text":"Prefecto is a collection of tools to extend and augment Prefect capabilities.","title":"Prefecto"},{"location":"#getting-started","text":"Install Prefecto with pip install prefecto Prefecto is only tested with Python 3.10 and higher. It may work with older versions, but it is not guaranteed. Break Task.map into smaller concurrent batches . from prefect import flow, task from prefecto.concurrency import BatchTask, CountSwitch @task def my_task(x): if x % 100 == 0: raise ValueError(f\"{x} is divisible by 100.\") return x @flow def my_flow(): results = BatchTask( my_task, size=100, kill_switch=CountSwitch(15), ).map(range(1000)) Simply and efficiently define and load blocks for dev/test/prod environments. # .env BLOCKS_PASSWORD_BLOCK=secret-password-test from prefect.blocks.system import Secret from prefecto.blocks import lazy_load from pydantic_settings import BaseSettings, SettingsConfigDict class Blocks(BaseSettings): \"\"\"Class for lazy loading Prefect Blocks.\"\"\" model_config = SettingsConfigDict(env_prefix=\"BLOCKS_\") # Define the block name variables password_block: str = \"secret-password\" @property @lazy_load(\"password_block\") def password(self) -> Secret: \"\"\"The password block.\"\"\" blocks = Blocks() password = blocks.password print(password.password_block) # secret-password-test print(password.get()) # my-secret-test-password$123","title":"Getting Started"},{"location":"blocks/","text":"Blocks A module for lazy loading Prefect Blocks. The @lazy_load decorator is centered around a model to attach blocks to. Each block is defined with two parts: a block name and a block property. The block name is a string that identifies the block. The block property is a property that loads the block on first access. The block property should be decorated with the @lazy_load decorator, and the block's type should be specified in the property annotations. Example: from prefect.blocks.system import Secret from prefecto.blocks import lazy_load class Blocks: \"\"\"Class for lazy loading Prefect Blocks.\"\"\" # Define the block name variables password_block: str = \"secret-password\" @property @lazy_load(\"password_block\") def password(self) -> Secret: \"\"\"The password block.\"\"\" blocks = Blocks() password = blocks.password print(password) # Secret(value=SecretStr('**********')) print(password.get()) # my-secret-password$123 This technique is useful for preventing the blocks from loading until they are actually needed. This can be important during unit testing, where connections to the Prefect server may not exist. The alternative would be to call block.load() directly, which would load the block every time it is called and could lead to performance issues. The loader can be integrated with pydantic-settings to load block names from environment variables. This can be achieved by setting the block name variables as class variables with default values set to the environment variables. Example: from pydantic_settings import BaseSettings, SettingsConfigDict from prefect.blocks.system import Secret from prefecto.blocks import lazy_load class Blocks(BaseSettings): \"\"\"Class for lazy loading Prefect Blocks.\"\"\" model_config = SettingsConfigDict(env_prefix=\"BLOCKS_\") # Define the block name variables password_block: str = \"secret-password\" @property @lazy_load(\"password_block\") def password(self) -> Secret: \"\"\"The password block.\"\"\" lazy_load ( varname ) Decorator for lazy loading a block. Parameters: varname ( str ) \u2013 The variable name of the block name var. Returns: \u2013 The decorator for the loader. Example: Specify the block name, then create a decorated property to load the block on first access. class MyClass: block_name = \"block_name\" @property @lazy_load(\"block_name\") def block(self) -> BlockType: \"\"\"The block.\"\"\" load_block ( block_type , block_name ) async Load a block. Parameters: block_type ( type [ Block ] ) \u2013 The block type. block_name ( str ) \u2013 The block name.","title":"Blocks"},{"location":"blocks/#blocks","text":"A module for lazy loading Prefect Blocks. The @lazy_load decorator is centered around a model to attach blocks to. Each block is defined with two parts: a block name and a block property. The block name is a string that identifies the block. The block property is a property that loads the block on first access. The block property should be decorated with the @lazy_load decorator, and the block's type should be specified in the property annotations. Example: from prefect.blocks.system import Secret from prefecto.blocks import lazy_load class Blocks: \"\"\"Class for lazy loading Prefect Blocks.\"\"\" # Define the block name variables password_block: str = \"secret-password\" @property @lazy_load(\"password_block\") def password(self) -> Secret: \"\"\"The password block.\"\"\" blocks = Blocks() password = blocks.password print(password) # Secret(value=SecretStr('**********')) print(password.get()) # my-secret-password$123 This technique is useful for preventing the blocks from loading until they are actually needed. This can be important during unit testing, where connections to the Prefect server may not exist. The alternative would be to call block.load() directly, which would load the block every time it is called and could lead to performance issues. The loader can be integrated with pydantic-settings to load block names from environment variables. This can be achieved by setting the block name variables as class variables with default values set to the environment variables. Example: from pydantic_settings import BaseSettings, SettingsConfigDict from prefect.blocks.system import Secret from prefecto.blocks import lazy_load class Blocks(BaseSettings): \"\"\"Class for lazy loading Prefect Blocks.\"\"\" model_config = SettingsConfigDict(env_prefix=\"BLOCKS_\") # Define the block name variables password_block: str = \"secret-password\" @property @lazy_load(\"password_block\") def password(self) -> Secret: \"\"\"The password block.\"\"\"","title":"Blocks"},{"location":"blocks/#src.prefecto.blocks.lazy_load","text":"Decorator for lazy loading a block. Parameters: varname ( str ) \u2013 The variable name of the block name var. Returns: \u2013 The decorator for the loader. Example: Specify the block name, then create a decorated property to load the block on first access. class MyClass: block_name = \"block_name\" @property @lazy_load(\"block_name\") def block(self) -> BlockType: \"\"\"The block.\"\"\"","title":"lazy_load"},{"location":"blocks/#src.prefecto.blocks.load_block","text":"Load a block. Parameters: block_type ( type [ Block ] ) \u2013 The block type. block_name ( str ) \u2013 The block name.","title":"load_block"},{"location":"license/","text":"License MIT License Copyright (c) 2023 Dominic Tarro Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright (c) 2023 Dominic Tarro Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"logging/","text":"Logging Prefect logging utilities. get_prefect_or_default_logger ( __default = None ) Gets the Prefect logger if the global context is set. Returns the __default or root logger if not.","title":"Logging"},{"location":"logging/#logging","text":"Prefect logging utilities.","title":"Logging"},{"location":"logging/#src.prefecto.logging.get_prefect_or_default_logger","text":"Gets the Prefect logger if the global context is set. Returns the __default or root logger if not.","title":"get_prefect_or_default_logger"},{"location":"concurrency/batch_task/","text":"BatchTask Module to improve Prefect concurrency operations. BatchTask Wraps a Task to perform Task.map in batches, reducing the number of concurrent tasks, mellowing Prefect API requests, and allowing for faster failure detection. from prefect import flow, task from prefecto.concurrency import BatchTask @task def add(a, b): return a + b @flow def my_flow(): batch_add = BatchTask(add, 2) return batch_add.map([1,2,3,4], [2,3,4,5]) The kill_switch argument can be used to stop the execution of the task after a certain condition is met. from prefect import flow, task from prefecto.concurrency import BatchTask, AnyFailedSwitch @task def add(a, b): return a + b @flow def my_flow(): batch_add = BatchTask(add, 2, kill_switch=AnyFailedSwitch()) # This will error on the first batch and stop the execution. return batch_add.map([1,2,3,4], [1,'2',3,4]) See kill switches for more information. __init__ ( task , size , kill_switch = None ) Wrap the task to be executed in batches of size . Args: task (Task): The task to wrap. size (int): The size of the batches to perform `Task.map` on. kill_switch (KillSwitch, optional): A kill switch to stop the execution of the task after a certain condition is met. map ( * args , ** kwds ) Perform a Task.map operation in batches of the keyword arguments. The arguments must be iterables of equal length. Args: *args: Positional arguments to pass to the task. **kwds: Keyword arguments to pass to the task. Returns: list [ PrefectFuture ] \u2013 A list of futures for each batch. Examples: ```python from prefect import flow, task from prefecto.concurrency import BatchTask @task def add(a, b): return a + b @flow def my_flow(): batch_add = BatchTask(add, 2) return batch_add.map([1,2,3,4], [2,3,4,5]) print(my_flow()) ``` ```log $ python my_flow.py 01:31:51.012 | INFO | prefect.engine - Created flow run 'beryl-moth' for flow 'test' 01:31:52.238 | DEBUG | Flow run 'beryl-moth' - Mapping 'add' batch 1 of 2. 01:31:52.239 | INFO | Flow run 'beryl-moth' - Created task run 'add-0' for task 'add' 01:31:52.240 | INFO | Flow run 'beryl-moth' - Submitted task run 'add-0' for execution. 01:31:52.253 | INFO | Flow run 'beryl-moth' - Created task run 'add-1' for task 'add' 01:31:52.254 | INFO | Flow run 'beryl-moth' - Submitted task run 'add-1' for execution. 01:31:52.259 | DEBUG | Flow run 'beryl-moth' - Mapping 'add' batch 2 of 2. 01:31:52.258 | INFO | Flow run 'beryl-moth' - Created task run 'add-3' for task 'add' 01:31:52.258 | INFO | Flow run 'beryl-moth' - Submitted task run 'add-3' for execution. 01:31:52.260 | INFO | Flow run 'beryl-moth' - Created task run 'add-2' for task 'add' 01:31:52.261 | INFO | Flow run 'beryl-moth' - Submitted task run 'add-2' for execution. 01:31:52.675 | INFO | Task run 'add-1' - Finished in state Completed() 01:31:52.770 | INFO | Task run 'add-0' - Finished in state Completed() 01:31:52.885 | INFO | Task run 'add-2' - Finished in state Completed() 01:31:53.075 | INFO | Task run 'add-3' - Finished in state Completed() 01:31:53.979 | INFO | Flow run 'beryl-moth' - Finished in state Completed() ``` ```json [3, 5, 7, 9] ```","title":"Batch Task"},{"location":"concurrency/batch_task/#batchtask","text":"Module to improve Prefect concurrency operations.","title":"BatchTask"},{"location":"concurrency/batch_task/#src.prefecto.concurrency.batch_task.BatchTask","text":"Wraps a Task to perform Task.map in batches, reducing the number of concurrent tasks, mellowing Prefect API requests, and allowing for faster failure detection. from prefect import flow, task from prefecto.concurrency import BatchTask @task def add(a, b): return a + b @flow def my_flow(): batch_add = BatchTask(add, 2) return batch_add.map([1,2,3,4], [2,3,4,5]) The kill_switch argument can be used to stop the execution of the task after a certain condition is met. from prefect import flow, task from prefecto.concurrency import BatchTask, AnyFailedSwitch @task def add(a, b): return a + b @flow def my_flow(): batch_add = BatchTask(add, 2, kill_switch=AnyFailedSwitch()) # This will error on the first batch and stop the execution. return batch_add.map([1,2,3,4], [1,'2',3,4]) See kill switches for more information.","title":"BatchTask"},{"location":"concurrency/batch_task/#src.prefecto.concurrency.batch_task.BatchTask.__init__","text":"Wrap the task to be executed in batches of size . Args: task (Task): The task to wrap. size (int): The size of the batches to perform `Task.map` on. kill_switch (KillSwitch, optional): A kill switch to stop the execution of the task after a certain condition is met.","title":"__init__"},{"location":"concurrency/batch_task/#src.prefecto.concurrency.batch_task.BatchTask.map","text":"Perform a Task.map operation in batches of the keyword arguments. The arguments must be iterables of equal length. Args: *args: Positional arguments to pass to the task. **kwds: Keyword arguments to pass to the task. Returns: list [ PrefectFuture ] \u2013 A list of futures for each batch. Examples: ```python from prefect import flow, task from prefecto.concurrency import BatchTask @task def add(a, b): return a + b @flow def my_flow(): batch_add = BatchTask(add, 2) return batch_add.map([1,2,3,4], [2,3,4,5]) print(my_flow()) ``` ```log $ python my_flow.py 01:31:51.012 | INFO | prefect.engine - Created flow run 'beryl-moth' for flow 'test' 01:31:52.238 | DEBUG | Flow run 'beryl-moth' - Mapping 'add' batch 1 of 2. 01:31:52.239 | INFO | Flow run 'beryl-moth' - Created task run 'add-0' for task 'add' 01:31:52.240 | INFO | Flow run 'beryl-moth' - Submitted task run 'add-0' for execution. 01:31:52.253 | INFO | Flow run 'beryl-moth' - Created task run 'add-1' for task 'add' 01:31:52.254 | INFO | Flow run 'beryl-moth' - Submitted task run 'add-1' for execution. 01:31:52.259 | DEBUG | Flow run 'beryl-moth' - Mapping 'add' batch 2 of 2. 01:31:52.258 | INFO | Flow run 'beryl-moth' - Created task run 'add-3' for task 'add' 01:31:52.258 | INFO | Flow run 'beryl-moth' - Submitted task run 'add-3' for execution. 01:31:52.260 | INFO | Flow run 'beryl-moth' - Created task run 'add-2' for task 'add' 01:31:52.261 | INFO | Flow run 'beryl-moth' - Submitted task run 'add-2' for execution. 01:31:52.675 | INFO | Task run 'add-1' - Finished in state Completed() 01:31:52.770 | INFO | Task run 'add-0' - Finished in state Completed() 01:31:52.885 | INFO | Task run 'add-2' - Finished in state Completed() 01:31:53.075 | INFO | Task run 'add-3' - Finished in state Completed() 01:31:53.979 | INFO | Flow run 'beryl-moth' - Finished in state Completed() ``` ```json [3, 5, 7, 9] ```","title":"map"},{"location":"concurrency/kill_switch/","text":"Kill Switches Kill switch logic classes for stopping the execution of a BatchTask . KillSwitch Bases: ABC Abstract base class for a kill switch. Each invocation of the should_flip_switch method should advance the state of the kill switch and return if the kill switch should be activated. The raise_if_triggered method should raise a KillSwitchError if the kill switch has been activated. class AnyFailedSwitch(KillSwitch): def should_flip_switch(self, state: State) -> bool: return state.is_failed() or state.is_crashed() def raise_if_triggered(self, state: State): if self.should_flip_switch(state): raise KillSwitchError(\"Failed task detected.\", self) raise_if_triggered ( state ) abstractmethod Check a state and raise a KillSwitchError if the kill switch has been activated. Raises: KillSwitchError \u2013 If the kill switch has been activated. should_flip_switch ( state ) abstractmethod Check if this state should flip the kill switch. Returns: bool \u2013 True if the kill switch should be activated, False otherwise. AnyFailedSwitch Bases: KillSwitch A kill switch that activates if any task fails. raise_if_triggered ( state ) Raise a KillSwitchError if the state is failed or crashed. should_flip_switch ( state ) Check if the state is failed or crashed. CountSwitch Bases: KillSwitch A kill switch that activates after a certain number of tasks fail. Parameters: count ( int ) \u2013 The number of failed or crashed states that should trigger the kill switch. raise_if_triggered ( state ) Raise a KillSwitchError if the count exceeds the maximum. should_flip_switch ( state ) Increment the count if the state is failed or crashed and return if the count exceeds the maximum. RateSwitch Bases: KillSwitch A kill switch that activates after the failure rate exceeds a certain threshold. Requires a minimum number of states to sample. Parameters: min_sample ( int ) \u2013 The minimum number of states to sample. max_fail_rate ( float ) \u2013 The maximum frequency of failed or crashed states. raise_if_triggered ( state ) Raise a KillSwitchError if the failure rate equals or exceeds the maximum rate. should_flip_switch ( state ) Increment the count if the state is failed or crashed and return if the failure rate equals or exceeds the max rate.","title":"Kill Switches"},{"location":"concurrency/kill_switch/#kill-switches","text":"Kill switch logic classes for stopping the execution of a BatchTask .","title":"Kill Switches"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.KillSwitch","text":"Bases: ABC Abstract base class for a kill switch. Each invocation of the should_flip_switch method should advance the state of the kill switch and return if the kill switch should be activated. The raise_if_triggered method should raise a KillSwitchError if the kill switch has been activated. class AnyFailedSwitch(KillSwitch): def should_flip_switch(self, state: State) -> bool: return state.is_failed() or state.is_crashed() def raise_if_triggered(self, state: State): if self.should_flip_switch(state): raise KillSwitchError(\"Failed task detected.\", self)","title":"KillSwitch"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.KillSwitch.raise_if_triggered","text":"Check a state and raise a KillSwitchError if the kill switch has been activated. Raises: KillSwitchError \u2013 If the kill switch has been activated.","title":"raise_if_triggered"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.KillSwitch.should_flip_switch","text":"Check if this state should flip the kill switch. Returns: bool \u2013 True if the kill switch should be activated, False otherwise.","title":"should_flip_switch"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.AnyFailedSwitch","text":"Bases: KillSwitch A kill switch that activates if any task fails.","title":"AnyFailedSwitch"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.AnyFailedSwitch.raise_if_triggered","text":"Raise a KillSwitchError if the state is failed or crashed.","title":"raise_if_triggered"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.AnyFailedSwitch.should_flip_switch","text":"Check if the state is failed or crashed.","title":"should_flip_switch"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.CountSwitch","text":"Bases: KillSwitch A kill switch that activates after a certain number of tasks fail. Parameters: count ( int ) \u2013 The number of failed or crashed states that should trigger the kill switch.","title":"CountSwitch"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.CountSwitch.raise_if_triggered","text":"Raise a KillSwitchError if the count exceeds the maximum.","title":"raise_if_triggered"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.CountSwitch.should_flip_switch","text":"Increment the count if the state is failed or crashed and return if the count exceeds the maximum.","title":"should_flip_switch"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.RateSwitch","text":"Bases: KillSwitch A kill switch that activates after the failure rate exceeds a certain threshold. Requires a minimum number of states to sample. Parameters: min_sample ( int ) \u2013 The minimum number of states to sample. max_fail_rate ( float ) \u2013 The maximum frequency of failed or crashed states.","title":"RateSwitch"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.RateSwitch.raise_if_triggered","text":"Raise a KillSwitchError if the failure rate equals or exceeds the maximum rate.","title":"raise_if_triggered"},{"location":"concurrency/kill_switch/#src.prefecto.concurrency.kill_switch.RateSwitch.should_flip_switch","text":"Increment the count if the state is failed or crashed and return if the failure rate equals or exceeds the max rate.","title":"should_flip_switch"}]}